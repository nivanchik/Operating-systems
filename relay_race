#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/msg.h>
#include <time.h>

#define MAX_RUNNERS 10
#define MSG_QUEUE_KEY 1000

#define MSG_REGISTER 1     
#define MSG_READY    2   
#define MSG_FINISH   3   
#define MSG_START_BASE 10 

struct msg_buf {
    long mtype;
    int runner_id;
};

void runner_process(int runner_id, int total_runners) {
    struct msg_buf msg;
    int msgq = msgget(MSG_QUEUE_KEY, 0666);
    
    printf("Участник %d: Здравствуйте! Я готов!\n", runner_id);
    msg.mtype = MSG_REGISTER;
    msg.runner_id = runner_id;
    msgsnd(msgq, &msg, sizeof(msg) - sizeof(long), 0);
    
    msgrcv(msgq, &msg, sizeof(msg) - sizeof(long), MSG_READY, 0);
    
    int my_start_type = MSG_START_BASE + runner_id;
    msgrcv(msgq, &msg, sizeof(msg) - sizeof(long), my_start_type, 0);
    
    printf("Участник %d: принял эстафету, начал бежать\n", runner_id);
    
    clock_t start = clock();
    while ((double)(clock() - start) / CLOCKS_PER_SEC < 0.1) {
    }
    
    if (runner_id < total_runners) {
        printf("Участник %d: передаю эстафету участнику %d\n", runner_id, runner_id + 1);
    }
    
    msg.mtype = MSG_FINISH;
    msg.runner_id = runner_id;
    msgsnd(msgq, &msg, sizeof(msg) - sizeof(long), 0);
    
    exit(0);
}

void judge_process(int total_runners) {
    struct msg_buf msg;
    int runners_ready = 0;
    int current_runner = 1;
    struct timespec start_time, finish_time;
    int msgq = msgget(MSG_QUEUE_KEY, 0666 | IPC_CREAT);
    
    printf("Судья: Добрый день! Я судья, жду %d участников\n\n", total_runners);
    
    while (runners_ready < total_runners) {
        msgrcv(msgq, &msg, sizeof(msg) - sizeof(long), MSG_REGISTER, 0);
        runners_ready++;
        printf("Судья: участник %d отмечен\n", msg.runner_id);
        
        msg.mtype = MSG_READY;
        msg.runner_id = msg.runner_id;
        msgsnd(msgq, &msg, sizeof(msg) - sizeof(long), 0);
    }
    
    printf("\nСудья: все в сборе! начинаем!\n\n");
    
    clock_gettime(CLOCK_MONOTONIC, &start_time);
    
    while (current_runner <= total_runners) {
        printf("Судья: передаю эстафету участнику %d\n", current_runner);
        
        msg.mtype = MSG_START_BASE + current_runner;
        msg.runner_id = current_runner;
        msgsnd(msgq, &msg, sizeof(msg) - sizeof(long), 0);
        
        msgrcv(msgq, &msg, sizeof(msg) - sizeof(long), MSG_FINISH, 0);
        
        printf("Судья: участник %d завершил круг\n\n", current_runner);
        
        current_runner++;
    }
    
    clock_gettime(CLOCK_MONOTONIC, &finish_time);
    
    double total_time = (finish_time.tv_sec - start_time.tv_sec) + 
                       (finish_time.tv_nsec - start_time.tv_nsec) / 1000000000.0;
    
    printf("Судья: эстафета завершена! Общее время: %.2f секунд\n", total_time);
    
    msgctl(msgq, IPC_RMID, NULL);
}

int main(int argc, char *argv[]) {
    int n = 4;
    
    if (argc > 1) {
        n = atoi(argv[1]);
        if (n < 1 || n > MAX_RUNNERS) n = 4;
    }
    
    printf("=== ЭСТАФЕТА ===\n\n");
    
    int msgq = msgget(MSG_QUEUE_KEY, 0666 | IPC_CREAT);
    if (msgq == -1) {
        perror("msgget");
        exit(1);
    }
    
    pid_t judge_pid = fork();
    if (judge_pid == 0) {
        judge_process(n);
        exit(0);
    } else if (judge_pid < 0) {
        perror("fork");
        exit(1);
    }
    
    sleep(1);
    
    pid_t pids[MAX_RUNNERS];
    for (int i = 1; i <= n; i++) {
        pids[i-1] = fork();
        if (pids[i-1] == 0) {
            runner_process(i, n);
        } else if (pids[i-1] < 0) {
            perror("fork");
            exit(1);
        }
    }
    
    for (int i = 0; i < n; i++) {
        wait(NULL);
    }
    
    wait(NULL);
    
    return 0;
}
